#include <windows.h>
#include <stdio.h>
#include <tchar.h>
#include <stdio.h>
#include <iostream>
#include <stddef.h>
using namespace std;

int main()
{
	char shellcode[] = { 0x89, 0xC8, 0xFF, 0xC0, 0xC3 };
	STARTUPINFO startupinfo;
	PROCESS_INFORMATION p;
	
	memset(&startupinfo,0,sizeof(startupinfo));
	
	int reaction = CreateProcess("E:\\C++ projects\\some.exe",NULL,NULL,NULL,0,CREATE_SUSPENDED,NULL,NULL,&startupinfo,&p);
	if (!reaction) {
		printf("Could not start process %d\n",GetLastError());
		return 1;
	}
	printf("The pid %d \n",p.dwProcessId);
	
	cout << "Attemplting to allocate memory in the remote process\n";
	
	void *pAddress = VirtualAllocEx(p.hProcess,NULL,sizeof(shellcode),MEM_COMMIT,PAGE_EXECUTE_READWRITE);
	if (!pAddress) {
		cout << "Error allocating space " << GetLastError() << endl;
		return 1;
	}
	
	std::size_t written = 0;
	reaction = WriteProcessMemory(p.hProcess,pAddress,shellcode,sizeof(shellcode),&written);
	if (!reaction) {
		cout << "Could not write to remote process " << GetLastError() << endl;
		return 1;
	}
	cout << "Writin to remote process was a success " << endl;
	cout << "Please enter to continue: ";
	
	cout<< (void *)p.hProcess << endl;
	HMODULE hnd = GetModuleHandle(TEXT("E:\\C++ projects\\some.exe"));
	if (!hnd) {
		cout << GetLastError() << endl;
	}
	cout << (void *)hnd << endl;
	//ReadProcessMemory(p.hProcess,)
	getchar();
	//ResumeThread(p.hThread);
	cout << p.hProcess << endl;
	
    
}
